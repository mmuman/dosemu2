/*
 *  Copyright (C) 2024  stsp
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <stddef.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <linux/prctl.h>  /* Definition of PR_* constants */
#include <sys/prctl.h>
#include <searpc.h>
#include "priv.h"
#include "sig.h"
#include "utilities.h"
#include "util.h"

/*
 * arg: rpc_client->arg. Normally a socket number
 * fcall_str: the JSON data stream generated by Searpc
 * fcall_len: the length of `fcall_str`
 * ret_len: place to get the length of the returned json data stream
 * Returns: A newly allocated string stores the JSON data stream
 */
static char *transport_callback(void *arg, const char *fcall_str,
        size_t fcall_len, size_t *ret_len)
{
    char buf[4096];
    int sock = (int)(uintptr_t)arg;
    ssize_t sd = send(sock, fcall_str, fcall_len, MSG_DONTWAIT);
    if (sd <= 0)
        return NULL;
    sd = recv(sock, buf, sizeof(buf), 0);
    if (sd <= 0)
        return NULL;
    *ret_len = sd;
    return g_strndup(buf, sd);
}

SearpcClient *clnt_init(int *sock_rx, int (*init_cb)(int, int, void *),
        void *init_arg, void (*run_cb)(void), void (*ex_cb)(void *))
{
    SearpcClient *clnt;
    int socks[2];
    int transp[2];
    pid_t pid;
    int err;
    pshared_sem_t svc_sem;

    err = socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, socks);
    if (err) {
        perror("socketpair()");
        return NULL;
    }
    err = socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, transp);
    if (err) {
        perror("socketpair()");
        goto err0;
    }
    err = pshared_sem_init(&svc_sem, 0);
    if (err)
        goto err1;
    pid = fork();
    switch (pid) {
        case -1:
            perror("fork()");
            goto err2;
        case 0:
            /* child */
            close(socks[0]);
            close(transp[0]);
            err = priv_drop();
            if (err) {
                pshared_sem_post(svc_sem);
                pshared_sem_destroy(&svc_sem);
                _exit(1);
            }
            setsid();
            prctl(PR_SET_PDEATHSIG, SIGQUIT);
            err = init_cb(transp[1], socks[1], init_arg);
            pshared_sem_post(svc_sem);
            pshared_sem_destroy(&svc_sem);
            if (err) {
                fprintf(stderr, "fs service failed\n");
                _exit(1);
            }
            run_cb();
            _exit(1);  // not reached
            break;
    }

    close(socks[1]);
    close(transp[1]);
    pshared_sem_wait(svc_sem);
    pshared_sem_destroy(&svc_sem);

    clnt = searpc_client_new();
    clnt->send = transport_callback;
    clnt->arg = (void *)(uintptr_t)transp[0];
    sigchld_register_handler(pid, ex_cb, NULL);
    *sock_rx = socks[0];
    return clnt;

err2:
    pshared_sem_destroy(&svc_sem);
err1:
    close(transp[0]);
    close(transp[1]);
err0:
    close(socks[0]);
    close(socks[1]);
    return NULL;
}
